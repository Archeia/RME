# -*- coding: utf-8 -*-
#==============================================================================
# ** RME V1.0.0 Database
#------------------------------------------------------------------------------
#  With : 
# Grim (original project)
# Nuki 
# Raho
#  Help :
# Fabien
# Zeus81
# Joke 
# Zangther
#------------------------------------------------------------------------------
# Provide two customs databases
#==============================================================================

#==============================================================================
# ** Object
#------------------------------------------------------------------------------
#  Add coersion stuff
#==============================================================================

class Object
  #--------------------------------------------------------------------------
  # * identity
  #--------------------------------------------------------------------------
  def nothing; self; end
  alias_method :noth, :nothing
  #--------------------------------------------------------------------------
  # * Magic coersion
  #--------------------------------------------------------------------------
  def db_cast_boolean
    return self if self.is_a?(TrueClass) || self.is_a?(FalseClass)
    return false unless self.respond_to?(:to_s)
    value = begin !!eval(self.to_s)
      rescue Exception => exc
        false
      end
  end
  alias_method :ptbo, :db_cast_boolean
end

#==============================================================================
# ** Types
#------------------------------------------------------------------------------
#  Minimalist types
#==============================================================================

module Types

  #--------------------------------------------------------------------------
  # * Singleton
  #--------------------------------------------------------------------------
  class << self
    #--------------------------------------------------------------------------
    # * Build a type
    #--------------------------------------------------------------------------
    def make(type)
      return CommonDB::TYPES.find{|t|t.match(type)} if type.is_a?(Symbol)
      if type.is_a?(Array)
        return Types::Complex.new(:list, (make(type[1])))
      end
    end
    #--------------------------------------------------------------------------
    # * Infer a type
    #--------------------------------------------------------------------------
    def inference(value)
      return :integer   if value.is_a?(Fixnum)
      return :float     if value.is_a?(Float)
      return :string    if value.is_a?(String)
      return :boolean   if value.is_a?(FalseClass) || value.is_a?(TrueClass)
      if value.is_a?(Array)
        v = value.compact
        return [:list, :poly] if v.length == 0 
        t = inference(v.first)
        return [:list, t] if v.all?{|x| inference(x) == t}
        return [:list, :poly]
      end
      return :poly
    end
  end

  #==============================================================================
  # ** Abstract
  #------------------------------------------------------------------------------
  #  Abstract type representation
  #==============================================================================
  
  class Abstract
    #--------------------------------------------------------------------------
    # * Public instance variable
    #--------------------------------------------------------------------------
    attr_accessor :coersion
    attr_accessor :name
    attr_accessor :names
    #--------------------------------------------------------------------------
    # * Constructor
    #--------------------------------------------------------------------------
    def initialize(name, names, coer)
      @name     = name
      @names    = names 
      coersion  = coer
      if coer.is_a?(Symbol)
        coersion = Proc.new {|x| x.send(coer)}
      end
      @coersion = coersion
    end
    #--------------------------------------------------------------------------
    # * Produce coersion
    #--------------------------------------------------------------------------
    def cast(x)
      self.coersion.call(x)
    end
    #--------------------------------------------------------------------------
    # * Check type name
    #--------------------------------------------------------------------------
    def match(label)
      return true if label.to_sym ==  @name.to_sym
      return @names.include?(label)
    end
  end

  #==============================================================================
  # ** Simple
  #------------------------------------------------------------------------------
  #  Simple type representation
  #==============================================================================

  class Simple < Abstract
    #--------------------------------------------------------------------------
    # * Public instance variables
    #--------------------------------------------------------------------------
    attr_accessor :is_rgss
    #--------------------------------------------------------------------------
    # * Constructor
    #--------------------------------------------------------------------------
    def initialize(name, names, coer, rgss = false)
      super(name, names, coer)
      @is_rgss = rgss
    end
    alias_method :rgss?, :is_rgss
  end

  #==============================================================================
  # ** Complex
  #------------------------------------------------------------------------------
  #  Complex type representation
  #==============================================================================

  class Complex < Abstract
    #--------------------------------------------------------------------------
    # * Instances variables
    #--------------------------------------------------------------------------
    attr_accessor :subtype
    #--------------------------------------------------------------------------
    # * Constructor
    #--------------------------------------------------------------------------
    def initialize(name, subtype)
      @subtype = subtype
      coersion = ->(subtype,x){x.collect{|y|subtype.cast(y)}}
      super(name, [], coersion.curry.call(@subtype))
    end
  end

end 
